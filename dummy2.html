
const approveReturn = async (req, res) => {
  try {
    const { orderId, productIndex } = req.params;
    console.log(" Params received:", req.params);
    const index = parseInt(productIndex);

    const order = await Order.findOne({ orderId });
    if (!order) return res.status(404).send('Order not found');
  //   console.log('Product index:', productIndex);
  //   console.log('Ordered items count:', order.orderedItems.length);
  //   const productItem = order.orderedItems[productIndex];
  //   console.log('Product item status:', productItem ? productItem.status : 'No product item');

    const productItem = order.orderedItems[index];
    if (!productItem || productItem.status !== 'return_requested') {
      return res.status(400).send('Invalid product or no return request found');
    }

    // Update stock for product color & size variant
    await Product.findByIdAndUpdate(productItem.product, {
      $inc: { 
        [`variants.$[elem].quantity`]: productItem.quantity
      }
    }, {
      arrayFilters: [
        { "elem.color": productItem.color, "elem.size": productItem.size }
      ]
    });

    
    order.orderedItems[index].status = 'returned';

    // Step 3: Recalculate subtotal excluding returned/cancelled items
    let newSubTotal = 0;
    order.orderedItems.forEach(item => {
      if (item.status !== 'returned' && item.status !== 'cancelled') {
        newSubTotal += item.finalPrice * item.quantity;
      }
    });
    order.subTotal = newSubTotal;

    const shippingCharge =order.subTotal > 0 && order.subTotal < 500 ? 50 : 0;
    order.deliveryCharge = shippingCharge;

  
    order.finalAmount = order.subTotal + order.deliveryCharge - order.discount;

   
    const allReturnedOrCancelled = order.orderedItems.every(item => 
      item.status === 'returned' || item.status === 'cancelled'
    );
    if (allReturnedOrCancelled) {
      order.status = 'returned';
    }
     // Credit refund to user's wallet
    const user = await User.findById(order.userId);
     if (user) {
    const itemTotal = productItem.finalPrice * productItem.quantity;

    let refundAmount = itemTotal;
    if (order.discount > 0 && order.subTotal > 0) {
      const proportionalDiscount = (itemTotal / order.subTotal) * order.discount;
      refundAmount -= proportionalDiscount;
      refundAmount = Math.round(refundAmount);
    }

    user.wallet += refundAmount;
    user.walletTransactions.push({
      amount: refundAmount,
      status: "credit",
      method: 'refund',
      description: `Refund for returned product (${productItem.productName}) in order ${order.orderId}`
    });

    await user.save();
  }
    await order.save();

    res.redirect(`/admin/order/${orderId}`);
  } catch (err) {
    console.error("Error in approveReturn:", err);
    res.status(500).send('Internal server error');
  }
};

const rejectReturn = async (req, res) => {
  try {
    const { orderId, productIndex } = req.params;

    const order = await Order.findOne({ orderId });
    if (!order) {
      return res.status(404).send('Order not found');
    }

    const productItem = order.orderedItems[productIndex];
    if (!productItem || productItem.status !== 'return_requested') {
      return res.status(400).send('Invalid product or no return request found');
    }

    // Mark the product status as 'return_rejected'
    order.orderedItems[productIndex].status = 'return_rejected';

    // Check if all ordered items are handled (delivered, cancelled, or return rejected)
    const allHandled = order.orderedItems.every(p =>
      ['delivered', 'cancelled', 'return_rejected'].includes(p.status)
    );

    // If all items handled, mark overall order as delivered
    if (allHandled) {
      order.status = 'delivered';
    }

    await order.save();

    res.redirect(`/admin/order/${orderId}`);
  } catch (err) {
    console.error(err);
    res.status(500).send('Internal server error');
  }
};

const loadReturnedProducts = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = 10;
    const skip = (page - 1) * limit;

    const returnedOrders = await Order.find({
      'orderedItems.status': { $in: ['return_requested', 'returned'] }
    })
      .populate('userId')
      .populate('orderedItems.product')
      .sort({ createdOn: -1 });

    let returnedItems = [];

    returnedOrders.forEach(order => {
      order.orderedItems.forEach(item => {
        if (['returned', 'return_requested'].includes(item.status)) {
          returnedItems.push({
            orderId: order.orderId,
            user: order.userId.name,
            product: item.product.name,
            quantity: item.quantity,
            status: item.status,
            date: order.createdOn.toISOString().split('T')[0],
            total: item.finalPrice * item.quantity
          });
        }
      });
    });

    const totalReturned = returnedItems.length;
    const totalPages = Math.ceil(totalReturned / limit);
    returnedItems = returnedItems.slice(skip, skip + limit); // Paginate array

    res.render('returnedProducts', {
      returnedItems,
      currentPage: page,
      totalPages
    });

  } catch (err) {
    console.error("Error loading returned products:", err);
    res.redirect('/pageerror');
  }
};


module.exports={
  listOrders,
  getOrderDetails,
  updateItemStatus ,
  approveReturn,
  rejectReturn,
  loadReturnedProducts 

}